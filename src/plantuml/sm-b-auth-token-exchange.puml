@startuml "SM-B-Auth-token-exchange"
autonumber "(00)"
skinparam defaultFontSize 10
skinparam defaultFontName Helvetica
skinparam DefaultMonospacedFontName Courier
skinparam lengthAdjust none

!pragma teoz true

Actor User
box "LEI" #GhostWhite
  box "Primärsystem" #Lavender
    box "ZETA Client" #SandyBrown
      participant Client as "ZETA\nClient"
    end box
    participant TPM as "TPM"
  end box
  participant Konnektor as "Konnektor or\nTI-Gateway"
  participant SMB as "SM(C)-B"
end box

box "Anbieter" #TECHNOLOGY
  box "ZETA Guard" #SandyBrown
    participant HP as "PEP\nhttp Proxy"
    participant AuthS as "PDP\nAuthorization Server" 
    participant PE as "PDP\nPolicy Engine"
  end box
    box TI 2.0 Dienst #DarkSeaGreen
      participant RS as "Resource Server"
    end box
end box

User -> Client: User wants to\naccess resource\non Resource Server
activate Client

== Discovery ==
group ZETA Client has Resource Server FQDN (RS-FQDN)
  Client -> HP: GET /.well-known/oauth-protected-resource Host: RS-FQDN
  activate HP
  HP --> Client: Client: 200 OK; json body with Well-Known json Document (RFC draft-ietf-oauth-resource-metadata)
  deactivate HP
  Client -> AuthS: GET /.well-known/oauth-authorization-server Host: AuthS-FQDN
  activate AuthS
  AuthS --> Client: 200 OK; json body with Well-Known json Document (RFC8414)
  deactivate AuthS
  
  note right of Client
    Offene Fragen:
    - Werden die Well-known JSON Dokumente signiert?
    - Wenn ja, welches Zertifikat wird für die Signatur verwendet?
    - Wie wird die Signatur überprüft?
  end note

end

== Dynamic Client Registration ==

alt Client has no Key Pair for Client Attestation
  alt Client uses TPM
    Client -> User: Require Admin\naccess to TPM
    User --> Client: TPM Admin access
    Client -> TPM: Create Client Attestation Key Pair in TPM
    activate TPM
    TPM --> Client: Public Attestation Key
    deactivate TPM
  else Client uses self signed Key (deprecated)
    Client -> Client: Create Client Key Pair
  end
end

group Client Registration
  Client -> Client: Create client statement
  Client -> AuthS: GET /nonce
  activate AuthS
  AuthS --> Client: return 200 OK new-nonce: nonce  
  Client -> TPM: Sign client statement
  activate TPM
  TPM --> Client: client statement Signature (Attestation Statement)
    Client -> TPM: Create "Certify Key" Quote for Attestation Key
    TPM --> Client: "Certify Key" Quote

  deactivate TPM

  Client -> AuthS: Client Registration Request
  note right: client_statement.yaml\nIncludes attestation statement, public key,\nand client statement
  AuthS --> Client: Client Registration Response\n(client_id)
  deactivate AuthS

  note right of Client
    Offene Fragen:
    - Wie wird die Signatur des Attestation Statements überprüft?
    - Wie wird die Signatur des Attestation Statements erstellt?
    - Beschreibung Client Registration Endpoint (RFC7591) in gemSpec_ZETA
    - Beschreibung Client Configuration Endpoint (RFC7592) in gemSpec_ZETA
  end note

end
== Token Exchange (under construction) ==
Client -> Client: generate DPoP key pair

alt Client has no valid refresh token
Client -> AuthS: GET /nonce
activate AuthS
AuthS --> Client: return 200 OK new-nonce: nonce
Client -> Client: create Client Assertion JWT with nonce\n  Client and OS Information\n  DPoP Thumbprint
Client -> Konnektor: externalAuthenticate JWT-hash
activate Konnektor
Konnektor -> SMB: sign JWT-hash
activate SMB
SMB -> Konnektor: JWT-Signature
deactivate SMB
Konnektor -> Client: JWT-signature
deactivate Konnektor

Client -> Client: add SM-B Signature to Client Assertion JWT\n\
cC4h... (Client Assertion JWT)
Client -> Client: create DPoP JWT with nonce
Client -> AuthS: POST /token\n\
  Content-Type: application/x-www-form-urlencoded\n\
  DPoP: ... (DPoP JWT)\n\
  grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer\n\
  assertion=eyJh... (Client Assertion JWT)
note left of AuthS
  RFC7523 (JWT Client Assertion), RFC9449 (DPoP)
end note
AuthS -> AuthS: verify Client Assertion JWT and DPoP JWT
AuthS -> AuthS: Create state for Identity/App/Device

else Client has valid Refresh token
Client -> Client: create DPoP JWT without nonce
Client -> AuthS: POST /token\n\
  DPoP: ... (DPoP JWT)\n\
  grant_type=refresh_token\n\
  refresh_token= ... (Refresh token)
AuthS -> AuthS: verify Refresh token and DPoP JWT
AuthS -> AuthS: invalidate Refresh token
end

AuthS -> PE: POST /v1/data/authz, json body {  "input": {...}} 
activate PE
PE --> AuthS: 200 OK, json body {"result": {"allow": true,\n\
"access_token_attributes": {...}}
deactivate PE
AuthS -> AuthS: issue Access and Refresh token with DPoP Binding\n\
  and Access token attributes
AuthS --> Client: 200 OK, Access token, Refresh token, bound to DPoP
deactivate AuthS

Client -> Client: Create DPoP Proof for RS
Client -> HP: GET /resource\n\
  Authorization: DPoP ... (Accesss token)\n\
  DPoP: ... (DPoP token)
activate HP
HP -> HP: verify Access token and DPoP Proof
HP -> HP: additional checks according to\n\
Access token attributes
HP -> RS: forward GET /resource\n\
with header and header content as json
activate RS
RS -> RS: provide\nresource\naccess
RS --> HP: 200 OK, resource
deactivate RS
HP --> Client: 200 OK, resource
deactivate HP
deactivate RS
deactivate Client

@enduml