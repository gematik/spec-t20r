@startuml "SM-B-Auth-token-exchange"
autonumber "(00)"
skinparam defaultFontSize 10
skinparam defaultFontName Helvetica
skinparam DefaultMonospacedFontName Courier
skinparam lengthAdjust none

!pragma teoz true

Actor User
box "LEI" #GhostWhite
  box "Primärsystem" #Lavender
    box "ZETA Client" #SandyBrown
      participant Client as "ZETA\nClient"
    end box
    participant TPM as "TPM"
  end box
  participant Konnektor as "Konnektor or\nTI-Gateway"
  participant SMB as "SM(C)-B"
end box

box "Anbieter" #TECHNOLOGY
  box "ZETA Guard" #SandyBrown
    participant HP as "PEP\nhttp Proxy"
    participant AuthS as "PDP\nAuthorization Server" 
    participant PE as "PDP\nPolicy Engine"
  end box
    box TI 2.0 Dienst #DarkSeaGreen
      participant RS as "Resource\nServer"
    end box
end box

User -> Client: User wants to\naccess resource\non Resource Server
activate Client

== Discovery ==

group ZETA Client has Resource Server FQDN (RS-FQDN)
  Client -> HP: GET /.well-known/oauth-protected-resource Host: RS-FQDN
  activate HP
  HP --> Client: Client: 200 OK; json body with Well-Known json Document (RFC draft-ietf-oauth-resource-metadata)
  deactivate HP
  Client -> AuthS: GET /.well-known/oauth-authorization-server Host: AuthS-FQDN
  activate AuthS
  AuthS --> Client: 200 OK; json body with Well-Known json Document (RFC8414)
  deactivate AuthS
  
  note right of Client
    Offene Fragen:
    - Werden die Well-known JSON Dokumente signiert?
    - Wenn ja, welches Zertifikat wird für die Signatur verwendet?
    - Wie wird die Signatur überprüft?
  end note

end

== Dynamic Client Registration ==
alt Client has no client_id

  Client -> AuthS: POST /register (RFC7591)
  activate AuthS
  AuthS --> Client: Client Information Response with client_id (RFC7591)
  deactivate AuthS
end

== Key Generation ==

alt Client has no Client Attestation Key Pair
  alt Client uses TPM
    Client -> User: Obtain Admin\naccess to TPM
    User --> Client: TPM Admin access
    Client -> TPM: Create Client Attestation Key Pair in TPM
    activate TPM
    TPM --> Client: Public Attestation Key
    deactivate TPM
  else Client uses self signed Attestation Key (deprecated)
    Client -> Client: Create self signed Client Attestation Key Pair
  end
end
alt Client has no Client Instance Key Pair
  Client -> Client: Create Client Instance Key Pair
end

alt Client has no valid refresh token

== Token Generation ==

  group SM(C)-B Access Token JWT

    Client -> Client: generate DPoP key pair

    Client -> Client: **Generate SM(C)-B Access Token JWT**\n("typ": "JWT", "alg": "ES256"\n"sub": "telematik_id",\n"scope": "RS specific scopes" "cnf": with public Client Attestation Key)
    Client -> Konnektor: externalAuthenticate SM(C)-B Access Token JWT-hash
    activate Konnektor
    Konnektor -> SMB: sign JWT-hash
    activate SMB
    SMB -> Konnektor: JWT-Signature
    deactivate SMB
    Konnektor -> Client: JWT-Signature
    deactivate Konnektor
    Client -> Client: Add JWT-Signature to SM(C)-B Access Token
  end

  group Client Attestation JWT
    Client -> Client: **Generate Client Attestation JWT**\n("typ": "oauth-client-attestation+jwt", "alg": "ES256"\n"sub": "client_id", "cnf" with public Client Instance Key)
    alt Client uses TPM
      Client -> TPM: Get TPM evidence
      TPM --> Client: TPM2B_ATTEST Objekt and TPM EK certificate chain
      Client -> Client: Add TPM evidence to Client Attestation JWT
      Client -> TPM: Sign Client Attestation JWT with Client Attestation Key
      activate TPM
      TPM --> Client: Client Attestation JWT Signature
      deactivate TPM
    else Client uses self signed Attestation Key (deprecated)
      Client -> Client: Sign Client Attestation JWT with Client Key
    end
  end

  group Client Attestation PoP and DPoP JWT
    Client -> AuthS: **GET /nonce**
    activate AuthS
    AuthS --> Client: return 200 OK new-nonce: nonce
    Client -> Client: **Generate Client Attestation PoP JWT**\n("typ": "oauth-client-attestation-pop+jwt", "nonce"\nsign with the private Client Instance Key)
    Client -> Client: **Generate DPoP JWT**\n("nonce", sign with the private DPoP Key)
  end

== Token Exchange ==

Client -> AuthS: **POST /token**\n\
POST /token HTTP/1.1\n\
Host: auths.example.com\n\
Content-Type: application/x-www-form-urlencoded\n\
OAuth-Client-Attestation: <Base64url-kodiertes Client Attestation JWT>\n\
OAuth-Client-Attestation-PoP: <Base64url-kodiertes Client Attestation PoP JWT>\n\
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange&\n\
subject_token=<SM(C)-B Access Token JWT>&\n\
subject_token_type=urn%3Aexample%3Asmc-b-jwt&\n\
audience=https%3A%2F%2Fbackend.example.com%2Fapi


/'
Client -> AuthS: **POST /token**\n\
  Content-Type: application/x-www-form-urlencoded\n\
  DPoP: ... (DPoP JWT)\n\
  grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer\n\
  assertion=eyJh... (Client Assertion JWT)
'/
note left of AuthS
  RFC7523 (JWT Client Assertion), RFC9449 (DPoP)
end note
AuthS -> AuthS: verify\n\
SM(C)-B Access Token JWT and DPoP JWT\n\
Client Attestation JWT and PoP JWT
AuthS -> AuthS: Create state for Session, Identity and Client

else Client has valid Refresh token

== Refresh Token Exchange ==

Client -> Client: create DPoP JWT without nonce
Client -> AuthS: POST /token\n\
  DPoP: ... (DPoP JWT)\n\
  grant_type=refresh_token\n\
  refresh_token= ... (Refresh token)
AuthS -> AuthS: verify Refresh token and DPoP JWT
AuthS -> AuthS: invalidate Refresh token
end

AuthS -> PE: POST /v1/data/authz, body {  "input": {...}} 
activate PE
PE --> AuthS: 200 OK, body {"allow": true,\n\
"access_token_ttl": "360",\n\
"refresh_token_ttl": "43200",\n\
"scope": "RS specific scopes"}
deactivate PE
AuthS -> AuthS: issue Access and Refresh token\nwith DPoP Binding
AuthS --> Client: 200 OK, Access token, Refresh token, bound to DPoP
deactivate AuthS

Client -> Client: Create DPoP Proof for RS
Client -> HP: GET /resource\n\
  Authorization: DPoP ... (Accesss token)\n\
  DPoP: ... (DPoP token)
activate HP
HP -> HP: verify Access token\nand DPoP Proof
HP -> RS: forward GET /resource\n\
with header and\nPEP header as json
activate RS
RS -> RS: provide\nresource\naccess
RS --> HP: 200 OK, Resource
deactivate RS
HP --> Client: 200 OK, Resource
deactivate HP
deactivate RS
Client --> User: Resource
deactivate Client

@enduml